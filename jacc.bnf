Program

	<program> ::= <block> | <program> <block>

Type

Blocks and Commands

	<block> ::= { <block_statements>? }
	<block_statements> ::= <block_statement> | <block_statements> <block_statement>
	<block_statement> ::= <decl_statement> | <functional_statement> | <misc_statement>
	<functional_statement> ::= empty
	<decl_statement> ::= empty
	<misc_statement> ::= <block> | <empty_statement> | <expression_statement> | <reserved_statement>
	<empty_statement> ::= ;
	<reserved_statement> ::= <break_statement> | <continue_statement> | <return_statement>
	<break_statement> ::= break;
	<continue_statement> ::= continue;
	<return_statement> ::= return <expression>;

Expressions

	<expression> ::= <assignment_expression>  
	<assignment_expression> ::= <conditional_expression> | <assignment>
	<assignment> ::= <left_hand_side> <assignment_operator> <assignment_expression>
	<left_hand_side> ::= <expression name>
	<assignment operator> ::= =
	<conditional_ expression> ::= <conditional_or_expression>
	<conditional_or_expression> ::= <conditional_and_expression> | <conditional_or_expression> || <conditional_and_expression>
	<conditional_and_expression> ::= <equality_expression> | conditional_expression> && <equality_expression>
	<equality_expression> ::= <relational_expression> | <equality_expression> == <relational_expression> | <equality_expression> != <relational_expression>
	<equality_expression> ::= <additive_expression> |  <relational_expression> > <additive_expression> | <relational_expression> <= <additve_expression> |  <relational_expression> > <additive_expression> | <relational_expression> >= <additive_expression>
	<additive_expression> ::= <multiplicative_expression> | <additive_expression> + <multiplicative_expression> | <additive_expression> - <multiplicative_expression> 
	<multiplicative expression> ::= <unary_expression> | <multiplicative_expression> * <unary_expression> | <multiplicative_expression> / <unary_expression> | <multiplicative_expression> % <unary_expression>
	<unary_expression> ::= + <unary_expression> | - <unary_expression> | <unary_expression_not_plus_minus>
	<unary_expression_not_plus_minus> ::= <postfix_expression> | ! <unary_expression>
	<postfix_expression> ::= <primary>
	<primary> ::= <primary_no_new_array>
	<primary_no_new_array> ::= <literal>

Token

	<literal> ::= <integer_literal> | <floating_point_literal> | <boolean_literal> | <character_literal> | <string_literal> | <null_literal>
	<integer_literal> ::= <decimal_integer_literal>
	<decimal_integer_literal> ::= <decimal_literal> <integer_type suffix>?
	<integer_type_suffix> ::=  l | L
	<decimal_literal> ::= 0 | <non_zero_digit><digits>?
	<digits> ::= <digit> | <digits> <digit>
	<digit> ::= 0 | <non_zero_digit>
	<non_zero_digit> ::= 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
	<floating_point_literal> ::= <digits>.<digits><float_type_suffix>?
	<float_type_suffix> ::= f | F | d | D
	<boolean literal> ::= true | false
	<character_literal> ::= '<single_character>' 
	<single_character> ::= <input_character>
	<string_literal> ::= "<string_characters>?"
	<string_characters> ::= <string_character> | <string characters> <string character>
	<string_character> ::= <input_character>
	<null literal> ::= null
	<identifier> ::= <valid_letter>|<identifier>(<valid_letter>|<digit>)
	<valid_letter> ::= <letter>|_|$
	<letter> ::= [a - z A - Z]

	<keyword> ::= abstract | boolean | break | byte | case | catch | char | class | const | continue | default | do | double | else | extends | final | finally | float | for | goto | if | implements |import | instanceof | int | interface | long | native | new | package | private | protected | public | return | short | static | super | switch | synchronized | this | throw | throws |transient | try | void | volatile | while

